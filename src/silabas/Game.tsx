import { useEffect, useState } from "react";
import "./Game.scss";
import { cloneDeep, isEqual } from "lodash";
import type { Puzzle, Syllable } from "./types";
import { addDateToLocalStorage } from "../utils/localstorage";
import Win from "../components/Win";
import { findFirstEmptySyllable, getSolution, initProgress } from "./helpers";
import { GameString } from "../types";

interface GameProps {
  puzzle: string[];
  todayString: string;
  /** if false, the puzzle was generated by the user using the UI generator */
  isDailyPuzzle?: boolean;
}

export default function Game(props: GameProps) {
  const [hasWon, setHasWon] = useState(false);
  const [showWinScreen, setShowWinScreen] = useState(false);
  const [activeWordIndex, setActiveWordIndex] = useState(0);
  /** active syllable within the active word */
  const [activeSyllableIndex, setActiveSyllableIndex] = useState(0);
  const solution = getSolution(props.puzzle);
  const [inProgressPuzzle, setInProgressPuzzle] = useState(
    initProgress(solution)
  );

  const win = () => {
    setHasWon(true);
    setShowWinScreen(true);
    if (props.isDailyPuzzle) {
      addDateToLocalStorage(GameString.Silabas, props.todayString);
    }
  };

  // check for win condition
  useEffect(() => {
    let hasLost = false;

    // only check if all syllables have been used
    if (!inProgressPuzzle.syllables.find((syllable) => !syllable.isInUse)) {
      solution.forEach((word, wordIndex) => {
        word.syllables.forEach((syllable, syllableIndex) => {
          if (
            syllable !==
            inProgressPuzzle.words[wordIndex].syllables[syllableIndex]
          ) {
            hasLost = true;
            return;
          }
        });
      });

      if (!hasLost) {
        win();
      }
    }
  }, [inProgressPuzzle.syllables]);

  // if syllable index is provided, set to that; otherwise set to the first empty syllable in the word
  const setActiveSyllable = (
    activeWordIndex: number,
    puzzleState: Puzzle,
    syllableIndex?: number
  ) => {
    if (syllableIndex && syllableIndex >= 0) {
      setActiveSyllableIndex(syllableIndex);
    } else {
      setActiveSyllableIndex(
        findFirstEmptySyllable(activeWordIndex, puzzleState)
      );
    }
  };

  const setSyllable = (
    wordIndex: number,
    syllableIndex: number,
    bankIndex: number,
    syllable: Syllable
  ) => {
    if (syllableIndex < 0) {
      console.warn("no active tile to place syllable");
      return;
    }

    const puzzle = cloneDeep(inProgressPuzzle);

    const activeWord = puzzle.words[wordIndex];
    if (activeWord.syllables[syllableIndex] !== "") {
      console.error("tried to set syllable where there already was one");
    } else {
      activeWord.syllables[syllableIndex] = syllable.text;
      puzzle.syllables[bankIndex].isInUse = true;
      setInProgressPuzzle(puzzle);
      setActiveSyllable(wordIndex, puzzle);
    }
  };

  const unsetSyllable = (wordIndex: number, syllableIndex: number) => {
    const puzzle = cloneDeep(inProgressPuzzle);

    const activeWord = puzzle.words[wordIndex];
    const activeSyllable = activeWord.syllables[syllableIndex];

    if (!activeSyllable) {
      console.error("tried to unset empty syllable");
    }

    const syllableInList = puzzle.syllables.find(
      (s) => s.text === activeSyllable
    );

    if (!syllableInList) {
      console.error("tried to unset empty syllable");
      return;
    }

    syllableInList.isInUse = false;

    activeWord.syllables[syllableIndex] = "";
    setInProgressPuzzle(puzzle);
    setActiveSyllable(wordIndex, puzzle, syllableIndex);
  };

  const onClickWord = (i: number) => {
    if (hasWon) return;

    setActiveWordIndex(i);

    if (isWordCorrect(i)) return;
    setActiveSyllable(i, inProgressPuzzle);
    // useEffect will set the activeSyllableIndex
  };

  const onClickBank = (syllable: Syllable, bankIndex: number) => {
    if (hasWon) return;

    if (syllable.isInUse) return;

    if (activeSyllableIndex < 0) {
      console.warn("word was full");
      return;
    }

    setSyllable(activeWordIndex, activeSyllableIndex, bankIndex, syllable);
  };

  const onClickSyllable = (
    wordIndex: number,
    syllableIndex: number,
    e: any
  ) => {
    e.stopPropagation();

    if (hasWon) return;
    if (isWordCorrect(wordIndex)) return;

    setActiveWordIndex(wordIndex);
    setActiveSyllableIndex(syllableIndex);

    const activeWord = inProgressPuzzle.words[wordIndex];
    if (activeWord.syllables[syllableIndex] !== "") {
      // remove the syllable just clicked
      unsetSyllable(wordIndex, syllableIndex);
    }
  };

  const closeWinScreen = () => {
    setShowWinScreen(false);
  };

  const isWordCorrect = (i: number): boolean => {
    return isEqual(inProgressPuzzle.words[i]?.syllables, solution[i].syllables);
  };

  return (
    <div className={`silabas-game ${hasWon ? "game-over" : ""}`}>
      {showWinScreen && (
        <Win closeWinScreen={closeWinScreen} canBeHidden={true} />
      )}
      <div className="game">
        {inProgressPuzzle.words.map((word, i) => (
          <div
            className={`word ${i === activeWordIndex ? "active" : ""} ${
              isWordCorrect(i) ? "correct" : ""
            }`}
            key={i}
            onClick={() => onClickWord(i)}
          >
            <div className="definition">{word.definition}</div>
            <div>
              {word.syllables.map((syllable, j) => (
                <div
                  className={`${syllable === "" ? "empty-syllable" : ""} ${
                    activeWordIndex === i && activeSyllableIndex === j
                      ? "active-syllable"
                      : ""
                  } syllable`}
                  onClick={(e) => onClickSyllable(i, j, e)}
                  key={j}
                >
                  {syllable}
                </div>
              ))}
            </div>
          </div>
        ))}
        <div className="bank">
          {inProgressPuzzle.syllables.map((syllable, i) => (
            <div
              className={`syllable ${syllable.isInUse ? "disabled" : ""}`}
              onClick={() => onClickBank(syllable, i)}
              key={i}
            >
              {syllable.text}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
