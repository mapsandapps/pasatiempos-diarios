import { useEffect, useState } from "react";
import "./MemoriaGame.scss";
import { addDateToLocalStorage } from "../utils/localstorage";
import { type InProgressSlot, type MemoriaPuzzle } from "./types";
import Win from "../components/Win";
import { GameString } from "../types";
import clsx from "clsx";
import EmojiTile from "../components/EmojiTile";

interface MemoriaGameProps {
  todayString: string;
  puzzle: MemoriaPuzzle;
  /** if false, the puzzle was generated by the user using the UI generator */
  isDailyPuzzle: boolean;
  /** is in colorblind mode if user has expressed a preference for that _and_ the puzzle needs it */
  isInColorblindMode: boolean;
  isInGeneratorMode?: boolean;
  hasArgentinianBias: boolean;
}

export default function MemoriaGame(props: MemoriaGameProps) {
  const {
    hasArgentinianBias,
    isDailyPuzzle,
    isInColorblindMode,
    puzzle,
    todayString,
  } = props;

  const [hasWon, setHasWon] = useState(false);
  const [showWinScreen, setShowWinScreen] = useState(false);
  const [inProgressPuzzle, setInProgressPuzzle] = useState<InProgressSlot[]>(
    puzzle.slots,
  );
  const [attemptedMatch, setAttemptedMatch] = useState<number[]>([]);

  const win = () => {
    setHasWon(true);
    setShowWinScreen(true);

    if (isDailyPuzzle) {
      addDateToLocalStorage(GameString.Memoria, todayString);
    }
  };

  useEffect(() => {
    // onInit
    setInProgressPuzzle(puzzle.slots);

    setHasWon(false);
    setShowWinScreen(false);
  }, [puzzle]);

  // check for win condition
  useEffect(() => {
    if (!inProgressPuzzle.find((slot) => !slot.hasBeenMatched)) {
      win();
    }
  }, [inProgressPuzzle]);

  const checkForMatch = (cardA: InProgressSlot, cardB: InProgressSlot) => {
    return cardA.pairIndex === cardB.pairIndex;
  };

  const clearAfterFailedMatch = () => {};

  const completeSuccessfulMatch = (pairIndex: number) => {
    setInProgressPuzzle((prevItems) => {
      return prevItems.map((slot) => {
        if (slot.pairIndex === pairIndex) {
          return { ...slot, hasBeenMatched: true };
        }
        return slot;
      });
    });
  };

  /** if there are two mismatched cards, and the user clicks one, flip both back to their backs */
  const onClickMismatched = (slotData: InProgressSlot) => {
    // first, check that they are mismatched
    // i.e. that two tiles are being checked
    if (attemptedMatch.length !== 2) return;

    // double-check that the card clicked is one in the attempted match
    if (attemptedMatch.includes(slotData.index)) {
      // flip the cards back over
      setAttemptedMatch([]);
    }
  };

  const onClickBack = (slotData: InProgressSlot) => {
    let nextMatchStatus = [...attemptedMatch];

    if (attemptedMatch.length > 1) {
      nextMatchStatus = [];
      clearAfterFailedMatch();
    }

    if (nextMatchStatus.length === 0) {
      setAttemptedMatch([slotData.index]);
    }

    if (nextMatchStatus.length === 1) {
      nextMatchStatus.push(slotData.index);
      const isMatch = checkForMatch(
        inProgressPuzzle[attemptedMatch[0]],
        slotData,
      );

      if (isMatch) {
        completeSuccessfulMatch(slotData.pairIndex);
        setAttemptedMatch([]);
      } else {
        clearAfterFailedMatch();
        setAttemptedMatch(nextMatchStatus);
      }
    }
  };

  const closeWinScreen = () => {
    setShowWinScreen(false);
  };

  return (
    <div className={clsx("memoria-game", hasWon && "game-over")}>
      {showWinScreen && <Win closeWinScreen={closeWinScreen} canBeHidden />}
      <div id="game">
        {inProgressPuzzle.map((slot, i) => {
          if (!slot || !slot.emoji) {
            return <div key={`slot-${i}`} className="emoji-tile empty-tile" />;
          }
          return (
            <EmojiTile
              key={`slot-${i}`}
              slotData={slot}
              onClickBack={onClickBack}
              onClickMismatched={onClickMismatched}
              isActive={attemptedMatch.includes(i)}
              iconDir={puzzle.iconDir}
              hasArgentinianBias={hasArgentinianBias}
              isInColorblindMode={isInColorblindMode}
            />
          );
        })}
      </div>
    </div>
  );
}
