import { useEffect, useMemo, useRef, useState } from "react";
import "./Game.scss";
import { addDateToLocalStorage } from "../utils/localstorage";
import type { Icon, IconToFind, Puzzle } from "./types";
import { cloneDeep, find, findLast } from "lodash";
import Win from "../components/Win";
import {
  getEnglishNameOfColor,
  isClickInIcon,
  numberRemaining,
} from "./helpers";
import { ICON_SIZE } from "./generator";
import React from "react";

const HINT_WAIT_TIME = 15; // seconds

interface GameProps {
  todayString: string;
  puzzle: Puzzle;
  /** if false, the puzzle was generated by the user using the UI generator */
  isDailyPuzzle: boolean;
  /** is in colorblind mode if user has expressed a preference for that _and_ the puzzle needs it */
  isInColorblindMode: boolean;
}

export default function Game(props: GameProps) {
  const { todayString, puzzle, isDailyPuzzle, isInColorblindMode } = props;

  const [hasWon, setHasWon] = useState(false);
  const [showWinScreen, setShowWinScreen] = useState(false);
  const [time, setTime] = useState(0);
  const [wrongIconClicked, setWrongIconClicked] = useState<Icon>();
  const [inProgressPuzzle, setInProgressPuzzle] = useState(puzzle);
  const clickAreaRef = useRef<HTMLDivElement>(null);
  const stopwatchRef = useRef<any>(null);

  // always will be the first `iconsToFind` that hasn't yet been found
  const currentIcon = useMemo(
    () => findLast(inProgressPuzzle.iconsToFind, ["hasBeenFound", false]),
    [inProgressPuzzle]
  );

  const markCurrentIconFound = () => {
    const puzzle = cloneDeep(inProgressPuzzle);

    const currentItem: IconToFind | undefined = find(puzzle.iconsToFind, [
      "spanishWord",
      currentIcon!.spanishWord,
    ]);

    if (!currentItem) console.error("icon not found in puzzle");

    currentItem!.hasBeenFound = true;

    setInProgressPuzzle(puzzle);
  };

  const onClickArea = (e: React.MouseEvent<HTMLDivElement>) => {
    setWrongIconClicked(undefined);

    if (hasWon) return;

    if (!currentIcon) console.error("icon not found in puzzle");

    if (clickAreaRef.current) {
      const rect = clickAreaRef.current?.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      if (isClickInIcon(currentIcon!, clickX, clickY)) {
        markCurrentIconFound();
        setTime(0);
      } else {
        // look thru `otherIcons` first, then `iconsToFind`. this order will insure the last match found is the correct (highest "z-index") one
        inProgressPuzzle.otherIcons.forEach((icon) => {
          if (isClickInIcon(icon, clickX, clickY)) {
            setWrongIconClicked(icon);
          }
        });
        inProgressPuzzle.iconsToFind.forEach((icon) => {
          if (!icon.hasBeenFound && isClickInIcon(icon, clickX, clickY)) {
            setWrongIconClicked(icon);
          }
        });
      }
    }
  };

  const win = () => {
    console.log("won!");
    setHasWon(true);
    setShowWinScreen(true);

    if (isDailyPuzzle) {
      addDateToLocalStorage("objeto-oculto", todayString);
    }
  };

  useEffect(() => {
    // onInit
    setInProgressPuzzle(puzzle);
    setHasWon(false);
    setShowWinScreen(false);

    setTime(0);
    stopwatchRef.current = setInterval(() => {
      setTime((prevTime) => prevTime + 1);
    }, 1000);

    // clean up
    return () => {
      clearInterval(stopwatchRef.current);
    };
  }, [puzzle]);

  // check for win condition
  useEffect(() => {
    if (numberRemaining(inProgressPuzzle.iconsToFind) < 1) {
      win();
    }
  }, [inProgressPuzzle]);

  // runs on re-render
  useEffect(() => {
    console.log(props);
  });

  return (
    <div className={`objeto-oculto-game ${hasWon ? "game-over" : ""}`}>
      {showWinScreen && <Win canBeHidden={false} />}
      <div id="game">
        {inProgressPuzzle.otherIcons.map((icon) => {
          return (
            <React.Fragment key={`fragment-${icon.spanishWord}`}>
              <img
                key={`${icon.spanishWord}`}
                src={icon.filePath}
                className="game-icon"
                width={`${ICON_SIZE}px`}
                height={`${ICON_SIZE}px`}
                style={{
                  left: `${icon.x}px`,
                  top: `${icon.y}px`,
                  transform: `rotate(${icon.rotation}deg)`,
                }}
              ></img>
              {isInColorblindMode && (
                <span
                  className={`english-word ${
                    icon.spanishWord === "negro" ? "dark-icon" : "light-icon"
                  }`}
                  style={{
                    left: `${icon.x}px`,
                    top: `${icon.y}px`,
                    transform: `rotate(${icon.rotation}deg)`,
                  }}
                >
                  {getEnglishNameOfColor(icon.spanishWord)}
                </span>
              )}
            </React.Fragment>
          );
        })}
        {inProgressPuzzle.iconsToFind.map((icon) => {
          if (icon.hasBeenFound) return;

          return (
            <React.Fragment key={`fragment-${icon.spanishWord}`}>
              <img
                src={icon.filePath}
                className="game-icon"
                width={`${ICON_SIZE}px`}
                height={`${ICON_SIZE}px`}
                data-spanishword={icon.spanishWord}
                style={{
                  left: `${icon.x}px`,
                  top: `${icon.y}px`,
                  transform: `rotate(${icon.rotation}deg)`,
                }}
              ></img>
              {isInColorblindMode && (
                <span
                  className={`english-word ${
                    icon.spanishWord === "negro" ? "dark-icon" : "light-icon"
                  }`}
                  style={{
                    left: `${icon.x}px`,
                    top: `${icon.y}px`,
                    transform: `rotate(${icon.rotation}deg)`,
                  }}
                >
                  {getEnglishNameOfColor(icon.spanishWord)}
                </span>
              )}
            </React.Fragment>
          );
        })}
        {wrongIconClicked && (
          <div
            className="wrong-icon-name"
            style={{
              left: `${wrongIconClicked.x}px`,
              top: `${wrongIconClicked.y}px`,
              opacity: 1,
            }}
            onAnimationEnd={() => setWrongIconClicked(undefined)}
          >
            {wrongIconClicked.spanishWord}
          </div>
        )}
        {currentIcon && (
          <div className="current-target">
            Find: {currentIcon!.spanishWord}{" "}
            {time > HINT_WAIT_TIME && (
              <span>
                {" "}
                (
                <img src={currentIcon.filePath} />)
              </span>
            )}
          </div>
        )}
        {numberRemaining(inProgressPuzzle.iconsToFind) <= 5 && (
          <div className="found-counter">
            {`${numberRemaining(inProgressPuzzle.iconsToFind)} remaining`}
          </div>
        )}
        <div id="click-area" ref={clickAreaRef} onClick={onClickArea}></div>
      </div>
    </div>
  );
}
