import { useEffect, useMemo, useRef, useState } from "react";
import "./Game.scss";
import { addDateToLocalStorage } from "../utils/localstorage";
import type { Icon, IconToFind, Puzzle } from "./types";
import { cloneDeep, find, findLast } from "lodash";
import Win from "../components/Win";
import { isClickInIcon, numberRemaining } from "./helpers";
import React from "react";
import Emoji from "./Emoji";

interface GameProps {
  todayString: string;
  puzzle: Puzzle;
  /** if false, the puzzle was generated by the user using the UI generator */
  isDailyPuzzle: boolean;
  /** is in colorblind mode if user has expressed a preference for that _and_ the puzzle needs it */
  isInColorblindMode: boolean;
}

export default function Game(props: GameProps) {
  const { todayString, puzzle, isDailyPuzzle, isInColorblindMode } = props;

  const [hasWon, setHasWon] = useState(false);
  const [showWinScreen, setShowWinScreen] = useState(false);
  const [wrongIconClicked, setWrongIconClicked] = useState<Icon>();
  const [inProgressPuzzle, setInProgressPuzzle] = useState(puzzle);
  const clickAreaRef = useRef<HTMLDivElement>(null);
  const stopwatchRef = useRef<any>(null);

  // always will be the first `iconsToFind` that hasn't yet been found
  const currentIcon = useMemo(
    () => findLast(inProgressPuzzle.iconsToFind, ["hasBeenFound", false]),
    [inProgressPuzzle]
  );

  const markCurrentIconFound = () => {
    const puzzle = cloneDeep(inProgressPuzzle);

    const currentItem: IconToFind | undefined = find(puzzle.iconsToFind, [
      "spanishWord",
      currentIcon!.spanishWord,
    ]);

    if (!currentItem) console.error("icon not found in puzzle");

    currentItem!.hasBeenFound = true;

    setInProgressPuzzle(puzzle);
  };

  const onClickArea = (e: React.MouseEvent<HTMLDivElement>) => {
    setWrongIconClicked(undefined);

    if (hasWon) return;

    if (!currentIcon) console.error("icon not found in puzzle");

    if (clickAreaRef.current) {
      const rect = clickAreaRef.current?.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      if (isClickInIcon(currentIcon!, clickX, clickY)) {
        markCurrentIconFound();
      } else {
        // look thru `otherIcons` first, then `iconsToFind`. this order will insure the last match found is the correct (highest "z-index") one
        inProgressPuzzle.otherIcons.forEach((icon) => {
          if (isClickInIcon(icon, clickX, clickY)) {
            setWrongIconClicked(icon);
          }
        });
        inProgressPuzzle.iconsToFind.forEach((icon) => {
          if (!icon.hasBeenFound && isClickInIcon(icon, clickX, clickY)) {
            setWrongIconClicked(icon);
          }
        });
      }
    }
  };

  const win = () => {
    setHasWon(true);
    setShowWinScreen(true);

    if (isDailyPuzzle) {
      addDateToLocalStorage("objeto-oculto", todayString);
    }
  };

  useEffect(() => {
    // onInit
    setInProgressPuzzle(puzzle);
    setHasWon(false);
    setShowWinScreen(false);

    // clean up
    return () => {
      clearInterval(stopwatchRef.current);
    };
  }, [puzzle]);

  // check for win condition
  useEffect(() => {
    if (numberRemaining(inProgressPuzzle.iconsToFind) < 1) {
      win();
    }
  }, [inProgressPuzzle]);

  return (
    <div className={`objeto-oculto-game ${hasWon ? "game-over" : ""}`}>
      {showWinScreen && <Win canBeHidden={false} />}
      <div id="game">
        {inProgressPuzzle.otherIcons.map((icon) => {
          return (
            <Emoji
              key={`emoji-${icon.spanishWord}`}
              icon={icon}
              isInColorblindMode={isInColorblindMode}
              iconType="Icon"
            />
          );
        })}
        {inProgressPuzzle.iconsToFind.map((icon) => {
          return (
            <Emoji
              key={`emoji-${icon.spanishWord}`}
              icon={icon}
              isInColorblindMode={isInColorblindMode}
              iconType="IconToFind"
            />
          );
        })}
        {wrongIconClicked && (
          <div
            // setting a key here means it will re-render when the "wrong icon" changes and therefore will restart the css animation
            key={wrongIconClicked.spanishWord}
            className="wrong-icon-name"
            style={{
              left: `${wrongIconClicked.x}px`,
              top: `${wrongIconClicked.y}px`,
              opacity: 1,
            }}
            onAnimationEnd={() => setWrongIconClicked(undefined)}
          >
            {wrongIconClicked.spanishWord}
          </div>
        )}
        {currentIcon && (
          <div className="current-target">
            Find: {currentIcon!.spanishWord}
            {/* setting a key here means it will re-render when the "current icon" changes and therefore will restart the css animation */}
            {/* the hint will animate in after n seconds */}
            <span key={currentIcon!.spanishWord} className="hint">
              {" "}
              (
              <img src={currentIcon.filePath} />)
            </span>
          </div>
        )}
        {numberRemaining(inProgressPuzzle.iconsToFind) <= 5 && (
          <div className="found-counter">
            {`${numberRemaining(inProgressPuzzle.iconsToFind)} remaining`}
          </div>
        )}
        <div id="click-area" ref={clickAreaRef} onClick={onClickArea}></div>
      </div>
    </div>
  );
}
